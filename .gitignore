# env
.env

# uploads 
actions/actions/uploads

# node_modules
node_modules


"use client";

import { useEffect, useRef, useState } from "react";
import ChatInput from "./ChatInput";
import type { Message } from "@/hooks/useChat";
import { getSocket } from "@/utils/socketSingleton";

interface ChatContainerProps {
  userId: string;
  otherUserId: string;
  roomId: string;
  messages: Message[];
  onSendMessage: (content: string, images?: string[], fileUrl?: string) => void;
  uploadFile: (file: File) => Promise<string>;
  onlineUsers: string[];
  onSendReaction: (messageId: string, type: string) => void;
}

const REACTIONS = ["üëç", "‚ù§Ô∏è", "üòÇ", "üòÆ", "üò¢", "üò°"];

export default function ChatContainer({
  userId,
  otherUserId,
  roomId,
  messages,
  onSendMessage,
  uploadFile,
  onlineUsers,
  onSendReaction,
}: ChatContainerProps) {
  const bottomRef = useRef<HTMLDivElement | null>(null);
  const [openReactionFor, setOpenReactionFor] = useState<string | null>(null);
  const [openActionFor, setOpenActionFor] = useState<string | null>(null);
  const [editingId, setEditingId] = useState<string | null>(null);
  const [editText, setEditText] = useState("");
  const editInputRef = useRef<HTMLInputElement | null>(null);
const [replyingMessage, setReplyingMessage] = useState<{
  messageId: string;
  userId: string;
  content?: string;
  images?: string[];
  fileUrl?: string;
} | null>(null);

  // LOCAL EDIT CACHE 
  const [editedCache, setEditedCache] = useState<Record<string, string>>({});

   const messageListRef = useRef<HTMLDivElement | null>(null);
const [showNewMsgBtn, setShowNewMsgBtn] = useState(false);
const [isAtBottom, setIsAtBottom] = useState(true);
const lastMsgIdRef = useRef<string | null>(null);
const [hasUnreadNewMsg, setHasUnreadNewMsg] = useState(false);
const API_BASE = "http://localhost:3001";

const resolveImageUrl = (img: string) => {
  if (img.startsWith("http://") || img.startsWith("https://")) {
    return img;
  }
  return `${API_BASE}${img}`;
};

  //  DELETE MENU STATE 
  const [openDeleteFor, setOpenDeleteFor] = useState<{
    messageId: string;
    isMine: boolean;
  } | null>(null);

  // HIDDEN MESSAGES (REMOVE FOR ME)
  const [hiddenMessages, setHiddenMessages] = useState<string[]>([]);
  useEffect(() => {
    const key = `hiddenMessages_${userId}_${roomId}`;
    const stored = localStorage.getItem(key);
    if (stored) {
      setHiddenMessages(JSON.parse(stored));
    } else {
      setHiddenMessages([]);
    }
  }, [userId, roomId]);

  //  REVOKED MESSAGES 
  const [revokedMessages, setRevokedMessages] = useState<string[]>([]);

//  SCROLL + HIGHLIGHT REPLY TARGET
const messageRefs = useRef<Record<string, HTMLDivElement | null>>({});
const [highlightMessageId, setHighlightMessageId] = useState<string | null>(null);

  //  TYPING STATE
  const [isTyping, setIsTyping] = useState(false);
  const typingTimeout = useRef<NodeJS.Timeout | null>(null);

  const socket = getSocket();

  const actionMenuRef = useRef<HTMLDivElement | null>(null);


  const handleRightClick = (e: React.MouseEvent, messageId: string) => {
    e.preventDefault();
    setOpenReactionFor(messageId);
  };

  // scroll khi c√≥ tin m·ªõi
useEffect(() => {
  if (!messages.length) return;

  const last = messages[messages.length - 1];
  if (!last?._id) return;

  if (lastMsgIdRef.current === last._id) return;
  lastMsgIdRef.current = last._id;

  //  CH√çNH M√åNH G·ª¨I ‚Üí LU√îN SCROLL
  if (last.userId === userId) {
    requestAnimationFrame(() => {
      bottomRef.current?.scrollIntoView({ behavior: "smooth" });
    });
    setHasUnreadNewMsg(false);
    return;
  }

  if (isAtBottom) {
    requestAnimationFrame(() => {
      bottomRef.current?.scrollIntoView({ behavior: "smooth" });
    });
  } else {
    setHasUnreadNewMsg(true);
  }
}, [messages, isAtBottom, userId]);

   // THEO D√ïI NG∆Ø·ªúI D√ôNG C√ì ƒêANG ·ªû CU·ªêI KH√îNG
  useEffect(() => {
  const el = messageListRef.current;
  if (!el) return;

  const handleScroll = () => {
    const distanceFromBottom =
      el.scrollHeight - el.scrollTop - el.clientHeight;

    const atBottom = distanceFromBottom < 80;
    setIsAtBottom(atBottom);

    if (atBottom) {
      setHasUnreadNewMsg(false);
    }
  };

  el.addEventListener("scroll", handleScroll);
  return () => el.removeEventListener("scroll", handleScroll);
}, []);


  // Close reaction bar
  useEffect(() => {
    const close = () => setOpenReactionFor(null);
    document.addEventListener("click", close);
    return () => document.removeEventListener("click", close);
  }, []);

  const isOtherOnline = onlineUsers.includes(otherUserId);

  const roomMessages = messages.filter((m) => m.roomId === roomId);

  const visibleMessages = roomMessages.filter(
    (m) => !hiddenMessages.includes(m._id!)
  );
  const lastMessage = visibleMessages[visibleMessages.length - 1];

  const isLastMine = lastMessage?.userId === userId;
  const isSeen = isLastMine && lastMessage?.readBy?.includes(otherUserId);
  const pinnedMessage = [...roomMessages]
  .reverse()
  .find((m) => m.isPinned);



//  X√ÅC ƒê·ªäNH N·ªòI DUNG HI·ªÇN TH·ªä CHO THANH GHIM
const getPinnedPreview = (msg: Message) => {
  if (msg.images && msg.images.length > 0) {
    return "·∫¢nh";
  }

  if (msg.fileUrl) {
    return "File";
  }

  return msg.content || "Tin nh·∫Øn";
};

  //  REALTIME SEEN
  useEffect(() => {
    const handler = ({
      roomId: rId,
      userId: reader,
    }: {
      roomId: string;
      userId: string;
    }) => {
      if (rId !== roomId) return;

      roomMessages.forEach((m) => {
        if (!m.readBy) m.readBy = [];
        if (!m.readBy.includes(reader)) {
          m.readBy.push(reader);
        }
      });
    };

    socket.on("messagesRead", handler);
    return () => socket.off("messagesRead", handler);
  }, [messages, roomId]); 
  

  //  REALTIME REVOKE MESSAGE (FOR EVERYONE)
  useEffect(() => {
    const handler = ({ messageId }: { messageId: string }) => {
      setRevokedMessages((prev) =>
        prev.includes(messageId) ? prev : [...prev, messageId]
      );
    };

    socket.on("messageRevoked", handler);
    return () => socket.off("messageRevoked", handler);
  }, []);



  //  CLICK RA NGO√ÄI ‚Üí H·ª¶Y EDIT
useEffect(() => {
  if (!editingId) return;

  const handleClickOutside = (e: MouseEvent) => {
    if (
      editInputRef.current &&
      !editInputRef.current.contains(e.target as Node)
    ) {
      setEditingId(null);
    }
  };

  document.addEventListener("mousedown", handleClickOutside);

  return () => {
    document.removeEventListener("mousedown", handleClickOutside);
  };
}, [editingId]);


 // REALTIME EDIT MESSAGE 
useEffect(() => {
  const handler = (payload: any) => {
    // Case 1: server emit { messageId, content }
    const messageId: string | undefined = payload?.messageId || payload?._id;
    const content: string | undefined = payload?.content;

    if (!messageId || typeof content !== "string") return;

    // cache n·ªôi dung m·ªõi ƒë·ªÉ UI update ngay m√† kh√¥ng s·ª≠a props
    setEditedCache((prev) => ({ ...prev, [messageId]: content }));

    // n·∫øu ƒëang edit ƒë√∫ng message ƒë√≥ th√¨ ƒë√≥ng input
    if (editingId === messageId) {
      setEditingId(null);
    }
  };

  socket.on("messageEdited", handler);
  return () => socket.off("messageEdited", handler);
}, [socket, editingId]);

  // reset cache theo room ƒë·ªÉ kh·ªèi "d√≠nh" room kh√°c
  useEffect(() => {
    setEditedCache({});
    setEditingId(null);
    setEditText("");
  }, [roomId]);

  //  CLICK RA NGO√ÄI ‚Üí ƒê√ìNG ACTION MENU
useEffect(() => {
  if (!openActionFor) return;

  const handleClickOutside = (e: MouseEvent) => {
    if (
      actionMenuRef.current &&
      !actionMenuRef.current.contains(e.target as Node)
    ) {
      setOpenActionFor(null);
    }
  };

  document.addEventListener("mousedown", handleClickOutside);

  return () => {
    document.removeEventListener("mousedown", handleClickOutside);
  };
}, [openActionFor]);

//  AUTO SCROLL KHI ƒê·ªîI ROOM
useEffect(() => {
  lastMsgIdRef.current = null;
  setHasUnreadNewMsg(false);

  requestAnimationFrame(() => {
    bottomRef.current?.scrollIntoView({ behavior: "auto" });
  });
}, [roomId]);



  //  REALTIME TYPING
  useEffect(() => {
    const handleTyping = ({
      roomId: r,
      userId: typingUser,
    }: {
      roomId: string;
      userId: string;
    }) => {
      if (r !== roomId) return;
      if (typingUser !== otherUserId) return;

      setIsTyping(true);

      if (typingTimeout.current) clearTimeout(typingTimeout.current);
      typingTimeout.current = setTimeout(() => setIsTyping(false), 1800);
    };

    const handleStopTyping = ({
      roomId: r,
      userId: typingUser,
    }: {
      roomId: string;
      userId: string;
    }) => {
      if (r !== roomId) return;
      if (typingUser !== otherUserId) return;

      setIsTyping(false);
    };

    socket.on("typing", handleTyping);
    socket.on("stopTyping", handleStopTyping);

    return () => {
      socket.off("typing", handleTyping);
      socket.off("stopTyping", handleStopTyping);
    };
  }, [roomId, otherUserId]);

  return (
    <div className="flex h-full flex-col">
      {/* HEADER */}
      <div className="flex items-center gap-3 border-b border-[#3A3B3C] bg-[#242526] px-4 py-3">
        <div className="relative h-12 w-12 rounded-full bg-gray-500">
          {isOtherOnline && (
            <span className="absolute -right-0.5 -bottom-0.5 h-3 w-3 rounded-full bg-green-500 border-2 border-[#242526]" />
          )}
        </div>

        <div className="flex flex-col">
          <h3 className="text-base font-semibold">{otherUserId}</h3>

          {isTyping ? (
            <span className="text-xs text-blue-400">ƒêang nh·∫≠p...</span>
          ) : (
            <div className="flex items-center gap-1">
              {isOtherOnline ? (
                <>
                  <span className="inline-block h-2 w-2 rounded-full bg-green-500" />
                  <span className="text-xs text-green-400">Online</span>
                </>
              ) : (
                <>
                  <span className="inline-block h-2 w-2 rounded-full bg-gray-400" />
                  <span className="text-xs text-gray-400">Offline</span>
                </>
              )}
            </div>
          )}
        </div>
      </div>


      {/*  PINNED MESSAGE BAR */}
{pinnedMessage && (
  <div className="flex items-center justify-between bg-yellow-500/10 px-4 py-2 text-sm text-yellow-300 border-b border-yellow-500/30">
    <div className="flex items-center gap-2 truncate">
      üìå
      <span className="truncate">
        {getPinnedPreview(pinnedMessage)}
      </span>

      <span className="text-xs text-yellow-400 opacity-80">
        ‚Äì {pinnedMessage.pinnedBy === userId ? "B·∫°n" : pinnedMessage.pinnedBy} ghim
      </span>
    </div>

    <button
      className="text-xs underline hover:text-yellow-400"
      onClick={() => {
        if (!pinnedMessage._id) return;

        const el = messageRefs.current[pinnedMessage._id];
        el?.scrollIntoView({ behavior: "smooth", block: "center" });
        setHighlightMessageId(pinnedMessage._id);
        setTimeout(() => setHighlightMessageId(null), 1500);
      }}
    >
      Xem
    </button>
  </div>
)}

      {/* MESSAGE LIST */}
      <div
  ref={messageListRef}
  className="flex-1 space-y-4 overflow-y-auto bg-[#18191A] p-4"
>

        {roomMessages
          .filter((msg) => !hiddenMessages.includes(msg._id!))
          .map((msg, idx, arr) => {
            const isMe = msg.userId === userId;
            const nextMsg = arr[idx + 1];

            //  RELOAD REVOKE
            const isRevoked = !!msg.isRevoked || revokedMessages.includes(msg._id!);

            const showAvatar =
              !isMe && (!nextMsg || nextMsg.userId !== msg.userId);

            const avatarSrc = `/avatars/${msg.userId}.png`;
            const reactions = msg.reactions ?? [];

            // content hi·ªÉn th·ªã 
            const displayContent =
              (msg._id && editedCache[msg._id]) ? editedCache[msg._id] : msg.content;

            // edited
            const showEditedTag = !!(msg.isEdited || (msg._id && editedCache[msg._id]));

            return (
              <div
  key={msg._id ?? idx}
  ref={(el) => {
    if (msg._id) {
      messageRefs.current[msg._id] = el;
    }
  }}
  className={`flex gap-2 ${isMe ? "justify-end" : "justify-start"}`}
>
                {!isMe ? (
                  showAvatar ? (
                    <img
                      src={avatarSrc}
                      className="h-6 w-6 rounded-full object-cover self-end mb-1"
                    />
                  ) : (
                    <div className="h-6 w-6" />
                  )
                ) : (
                  <div className="h-6 w-6" />
                )}

                <div className="relative flex max-w-[70%] flex-col group">
  {/* ‚ãØ ACTION MENU BUTTON */}
<button
  className={`
    absolute top-1/2 -translate-y-1/2
    ${isMe ? "-left-10" : "-right-10"}
    text-gray-400
    opacity-0
    group-hover:opacity-100
    transition
    hover:text-white
  `}
  onClick={(e) => {
    e.stopPropagation();
    setOpenActionFor(openActionFor === msg._id ? null : msg._id!);
  }}
>
  ‚ãØ
</button>

{/* ACTION MENU */}
{openActionFor === msg._id && (
  <div
    ref={actionMenuRef}
    className={`
      absolute z-50
      ${isMe ? "-left-36" : "left-full ml-2"}
      top-1/2 -translate-y-1/2
      w-36
      rounded-lg
      bg-[#242526]
      shadow-lg
      border border-gray-600
      text-sm
    `}
  >
    {/* ‚Ü©Ô∏è REPLY */}
    <button
      className="w-full px-3 py-2 text-left hover:bg-[#3A3B3C]"
      onClick={() => {
        setReplyingMessage({
          messageId: msg._id!,
          userId: msg.userId,
          content: msg.content,
          images: msg.images,
          fileUrl: msg.fileUrl,
        });
        setOpenActionFor(null);
      }}
    >
      ‚Ü©Ô∏è Tr·∫£ l·ªùi
    </button>

    {/* üìå PIN / UNPIN */}
<button
  className="w-full px-3 py-2 text-left hover:bg-[#3A3B3C]"
  onClick={() => {
    if (!msg._id) return;
if (msg.isPinned) {
  socket.emit("unpinMessage", { messageId: msg._id });
} else {
  socket.emit("pinMessage", { messageId: msg._id });
}



    setOpenActionFor(null);
  }}
>
  {msg.isPinned ? "üìå B·ªè ghim" : "üìå Ghim"}
</button>


    {/* ‚úèÔ∏è EDIT ‚Äî ch·ªâ tin c·ªßa m√¨nh */}
    {isMe && !isRevoked && msg.content && (
      <button
        className="w-full px-3 py-2 text-left hover:bg-[#3A3B3C]"
        onClick={() => {
          setEditingId(msg._id!);
          setEditText(displayContent || "");
          setOpenActionFor(null);
        }}
      >
        ‚úèÔ∏è Ch·ªânh s·ª≠a
      </button>
    )}

    {/* üóëÔ∏è DELETE */}
    <button
      className="w-full px-3 py-2 text-left text-red-400 hover:bg-[#3A3B3C]"
      onClick={() => {
        setOpenDeleteFor({
          messageId: msg._id!,
          isMine: isMe,
        });
        setOpenActionFor(null);
      }}
    >
      üóëÔ∏è Thu h·ªìi
    </button>
  </div>
)}

                  {/* MESSAGE CONTENT OR REVOKED */}
                 {isRevoked ? (
  <div
    className={`rounded-2xl px-4 py-2 text-sm italic ${
      isMe
        ? "rounded-br-none bg-[#3A3B3C] text-gray-300"
        : "rounded-bl-none bg-[#3A3B3C] text-gray-300"
    }`}
  >
    Tin nh·∫Øn ƒë√£ b·ªã thu h·ªìi
  </div>
) : (
  msg.content && (
    <>
      {/*  REPLY PREVIEW ‚Äî PH·∫¶N ƒê∆Ø·ª¢C TH√äM */}
      {msg.replyTo && (
  <div
    className={`
      mb-1 rounded-lg px-3 py-2 text-xs cursor-pointer
      ${isMe ? "bg-yellow-700/30" : "bg-gray-600/40"}
      border-l-4 border-blue-400
      hover:opacity-80
    `}
    onClick={() => {
      const targetId = msg.replyTo?.messageId;
      if (!targetId) return;

      const el = messageRefs.current[targetId];
      if (el) {
        el.scrollIntoView({
          behavior: "smooth",
          block: "center",
        });

        setHighlightMessageId(targetId);

        // t·∫Øt highlight 
        setTimeout(() => {
          setHighlightMessageId(null);
        }, 1500);
      }
    }}
  >
          <div className="font-semibold text-blue-400 mb-0.5">
            ‚Ü©Ô∏è {msg.replyTo.userId === userId ? "B·∫°n" : msg.replyTo.userId}
          </div>

          {msg.replyTo.content && (
            <div className="line-clamp-2 text-gray-200">
              {msg.replyTo.content}
            </div>
          )}

          {msg.replyTo.images?.length ? (
            <div className="italic text-gray-300">üì∑ ·∫¢nh</div>
          ) : msg.replyTo.fileUrl ? (
            <div className="italic text-gray-300">üìé File</div>
          ) : null}
        </div>
      )}

      {/* üí¨ MESSAGE BUBBLE ‚Äî GI·ªÆ NGUY√äN */}
      <div
        className={`
    rounded-2xl px-4 py-2 shadow transition-all duration-300
    ${
      isMe
        ? "rounded-br-none bg-primary text-white"
        : "rounded-bl-none bg-[#3A3B3C] text-white"
    }
    ${
      msg._id === highlightMessageId
        ? "ring-2 ring-blue-400 bg-blue-500/10 animate-pulse"
        : ""
    }
  `}
        onContextMenu={(e) => {
          e.preventDefault();
          if (!msg._id) return;
          setOpenReactionFor(msg._id);
        }}
      >
        {editingId === msg._id ? (
          <input
            value={editText}
             ref={editInputRef} 
            autoFocus
            onChange={(e) => setEditText(e.target.value)}
            onKeyDown={(e) => {
              if (!msg._id) return;

              if (e.key === "Enter") {
                const trimmed = editText.trim();
                if (!trimmed) {
                  setEditingId(null);
                  return;
                }

                socket.emit("editMessage", {
                  messageId: msg._id,
                  content: trimmed,
                });

                setEditingId(null);
              }

              if (e.key === "Escape") {
                setEditingId(null);
              }
            }}
            className="rounded-lg px-3 py-2 text-black w-full"
          />
        ) : (
          <>
  {msg.isPinned && (
    <span className="mr-1 inline-flex items-center text-yellow-400">
      üìå
    </span>
  )}

  <span>{displayContent}</span>

  {showEditedTag && (
    <span className="ml-1 text-[10px] italic text-gray-300">
      (ƒë√£ ch·ªânh s·ª≠a)
    </span>
  )}
</>

        )}
      </div>
    </>
  )
)}

                  {!revokedMessages.includes(msg._id!) &&
                    msg.images &&
                    msg.images.length > 0 && (
                      <div
  className={`
    mt-2 space-y-2 rounded-xl p-1 transition-all duration-300
    ${msg._id === highlightMessageId ? "ring-2 ring-blue-400 bg-blue-500/10 animate-pulse" : ""}
  `}
>

  {msg.images.map((img, k) => (
  <div key={k} className="relative inline-block">
    {/* üìå PIN ICON OVER IMAGE */}
    {msg.isPinned && (
      <span className="absolute top-2 right-2 z-10 text-yellow-400 text-lg drop-shadow">
        üìå
      </span>
    )}

   <img
  src={resolveImageUrl(img)}
  className="
    max-h-[300px] max-w-[260px]
    cursor-pointer rounded-xl shadow
    transition-all duration-300
  "
  onClick={() => window.open(resolveImageUrl(img), "_blank")}
  onContextMenu={(e) => handleRightClick(e, msg._id!)}
/>

  </div>
))}


                      </div>
                    )}

                  {!revokedMessages.includes(msg._id!) &&
                    msg.fileUrl &&
                    (!msg.images || msg.images.length === 0) && (
                      <div className="relative inline-block mt-2">
  {/* üìå PIN ICON OVER FILE */}
  {msg.isPinned && (
    <span className="absolute -top-2 -right-2 z-10 text-yellow-400 text-lg drop-shadow">
      üìå
    </span>
  )}

  <a
    href={msg.fileUrl}
    target="_blank"
    className={`
      rounded-lg px-3 py-2 text-sm shadow
      transition-all duration-300
      ${isMe ? "bg-primary text-white" : "bg-gray-200 text-gray-800"}
    `}
    onContextMenu={(e) => {
      e.preventDefault();
      if (!msg._id) return;
      setOpenReactionFor(msg._id);
    }}
  >
    üìé {msg.fileUrl.split("/").pop()}
  </a>
</div>)}


                  {openReactionFor === msg._id && (
                    <div
                      className={`absolute -top-8 ${
                        isMe ? "right-0" : "left-0"
                      } flex gap-2 rounded-full bg-[#3A3B3C] px-3 py-1 shadow-lg`}
                      onClick={(e) => e.stopPropagation()}
                    >
                      {REACTIONS.map((r) => (
                        <span
                          key={r}
                          className="cursor-pointer text-xl hover:scale-125 transition"
                          onClick={() => {
                            if (!msg._id) return;
                            onSendReaction(msg._id, r);
                            setOpenReactionFor(null);
                          }}
                        >
                          {r}
                        </span>
                      ))}
                    </div>
                  )}

                  {!revokedMessages.includes(msg._id!) && reactions.length > 0 && (
                    <div
                      className={`mt-1 flex gap-1 ${
                        isMe ? "justify-end" : "justify-start"
                      }`}
                    >
                      {reactions.map((r, i) => (
                        <span
                          key={r.userId + "_" + r.type + "_" + i}
                          className="inline-flex h-6 min-w-[24px] items-center justify-center rounded-full bg-[#3A3B3C] text-sm"
                        >
                          {r.type}
                        </span>
                      ))}
                    </div>
                  )}

                  <p className="mt-1 text-[10px] text-gray-500">
                    {msg.createdAt ? new Date(msg.createdAt).toLocaleTimeString() : ""}
                  </p>
                </div>
              </div>
            );
          })}

        {/* SEEN STATUS */}
        {isLastMine && (
          <div className="pr-2 text-right text-xs text-gray-400 flex items-center justify-end gap-1">
            {isSeen ? (
              <>
                <img
                  src={`/avatars/${otherUserId}.png`}
                  className="h-4 w-4 rounded-full object-cover"
                />
                <span>ƒê√£ xem</span>
              </>
            ) : (
              <span>ƒê√£ g·ª≠i</span>
            )}
          </div>
        )}

        {/* TYPING BUBBLE */}
        {isTyping && (
          <div className="flex items-end gap-2 mb-2">
            <img
              src={`/avatars/${otherUserId}.png`}
              className="h-6 w-6 rounded-full object-cover mb-1"
            />
            <div className="bg-[#3A3B3C] px-4 py-2 rounded-2xl rounded-bl-none flex gap-1">
              <span className="w-2 h-2 bg-gray-300 rounded-full animate-bounce" />
              <span className="w-2 h-2 bg-gray-300 rounded-full animate-bounce delay-150" />
              <span className="w-2 h-2 bg-gray-300 rounded-full animate-bounce delay-300" />
            </div>
          </div>
        )}

        {hasUnreadNewMsg && (
  <div className="sticky bottom-4 flex justify-center z-40">
    <button
      className="flex items-center gap-2 rounded-full bg-primary px-4 py-2 text-sm text-white shadow-lg"
      onClick={() => {
        bottomRef.current?.scrollIntoView({ behavior: "smooth" });
        setHasUnreadNewMsg(false);
      }}
    >
      ‚¨áÔ∏è C√≥ tin nh·∫Øn m·ªõi
    </button>
  </div>
)}



        <div ref={bottomRef} />
      </div>

      {/* DELETE MENU (UI ONLY) */}
      {openDeleteFor && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/40">
          <div className="w-80 rounded-xl bg-[#242526] p-4 shadow-xl">
            <h3 className="mb-3 text-center text-sm font-semibold text-white">
              G·ª° tin nh·∫Øn?
            </h3>

            <button
              className="w-full rounded-lg px-4 py-2 text-left text-sm text-white hover:bg-[#3A3B3C]"
              onClick={() => {
                const key = `hiddenMessages_${userId}_${roomId}`;

                setHiddenMessages((prev) => {
                  const updated = [...prev, openDeleteFor.messageId];
                  localStorage.setItem(key, JSON.stringify(updated));
                  return updated;
                });
                setOpenDeleteFor(null);
              }}
            >
              G·ª° ·ªü ph√≠a b·∫°n
            </button>

            {openDeleteFor.isMine && (
              <button
                className="mt-2 w-full rounded-lg px-4 py-2 text-left text-sm text-red-400 hover:bg-[#3A3B3C]"
                onClick={() => {
                  socket.emit("revokeMessage", {
                    messageId: openDeleteFor.messageId,
                  });
                  setOpenDeleteFor(null);
                }}
              >
                Thu h·ªìi cho m·ªçi ng∆∞·ªùi
              </button>
            )}

            <button
              className="mt-3 w-full rounded-lg px-4 py-2 text-sm text-gray-400 hover:bg-[#3A3B3C]"
              onClick={() => setOpenDeleteFor(null)}
            >
              H·ªßy
            </button>
          </div>
        </div>
      )}

      <ChatInput
  sendMessage={onSendMessage}
  uploadFile={uploadFile}
  roomId={roomId}
  replyingMessage={replyingMessage}
  clearReply={() => setReplyingMessage(null)}
/>
    </div>
  );
}