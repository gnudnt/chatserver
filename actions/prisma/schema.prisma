// This is your Prisma schema file

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==============================
// 1. ENUMS (Chuẩn hóa dữ liệu)
// ==============================

enum RoleName {
  USER
  ADMIN
  MODERATOR
}

enum Gender {
  MALE
  FEMALE
  OTHER
  PREFER_NOT_TO_SAY
}

enum MatchStatus {
  ACTIVE
  UNMATCHED
}

enum CallType {
  AUDIO
  VIDEO
}

enum ConnectionStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum PostStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum ModerationAction {
  WARN
  BAN
  MUTE
  DELETE_CONTENT
  NONE
}

enum ModerationStatus {
  PENDING
  RESOLVED
  DISMISSED
}

enum ContentType {
  TEXT
  IMAGE
  FILE
}

// ==============================
// 2. CORE USER & AUTH
// ==============================

model Role {
  id        String   @id @default(uuid()) @map("role_id") @db.Uuid
  name      RoleName @unique @map("role_name")
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamp
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamp

  users User[]

  @@map("roles")
}

model User {
  id              String    @id @default(uuid()) @map("user_id") @db.Uuid
  email           String    @unique @db.VarChar(255)
  password        String    @db.VarChar(255)
  isActive        Boolean   @default(true) @map("active")
  roleId          String    @map("role_id") @db.Uuid
  emailVerifiedAt DateTime? @map("email_verified_at") @db.Timestamp
  createdAt       DateTime  @default(now()) @map("created_at") @db.Timestamp
  updatedAt       DateTime  @updatedAt @map("updated_at") @db.Timestamp

  // Relations: Auth & Profile
  role        Role         @relation(fields: [roleId], references: [id])
  profile     Profile?
  verifyCodes VerifyCode[]

  // Relations: Actions
  swipesMade     Swipe[] @relation("Swiper")
  swipesReceived Swipe[] @relation("Target")

  matchesAsUser1 Match[] @relation("MatchUser1")
  matchesAsUser2 Match[] @relation("MatchUser2")

  messagesSent   Message[] @relation("MessageSender")
  
  callsInitiated Call[]    @relation("Caller")
  callsReceived  Call[]    @relation("Recipient")
  callsEnded     Call[]    @relation("CallEnder")

  // Relations: Community
  posts      CommunityPost[] @relation("PostAuthor")
  adminPosts CommunityPost[] @relation("PostAdmin")
  comments   Comment[]

  requestsSent     ConnectionRequest[] @relation("RequestFrom")
  requestsReceived ConnectionRequest[] @relation("RequestTo")

  // Relations: Moderation
  moderationsTarget   Moderation[]    @relation("ModTarget")
  moderationsReported Moderation[]    @relation("ModReporter")
  moderationsReviewed Moderation[]    @relation("ModReviewer")
  moderationLogs      ModerationLog[] @relation("ModLogAdmin")

  // Relations: System
  notifications Notification[]
  studySlots    UserStudySlot[]
  styleStats    UserStyleStats[]
  goalStats     UserGoalStats[]

  @@map("users")
}

model VerifyCode {
  id        String    @id @default(uuid()) @map("verify_code_id") @db.Uuid
  userId    String    @map("user_id") @db.Uuid
  type      String    @db.VarChar(50) // e.g., "REGISTER", "RESET_PASSWORD"
  code      String    @db.VarChar(10)
  usedAt    DateTime? @map("used_at") @db.Timestamp
  expiredAt DateTime  @map("expired_at") @db.Timestamp
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamp

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("verify_codes")
}

// ==============================
// 3. TAGS & LOOKUP TABLES
// ==============================

model TagSubject {
  id   String @id @default(uuid()) @map("tag_subject_id") @db.Uuid
  code String @unique @db.VarChar(50)
  name String @db.VarChar(255)

  profiles Profile[]

  @@map("tag_subjects")
}

model TagLevel {
  id   String @id @default(uuid()) @map("tag_level_id") @db.Uuid
  code String @unique @db.VarChar(50)
  name String @db.VarChar(255)

  profiles Profile[]

  @@map("tag_levels")
}

model TagStudyStyle {
  id   String @id @default(uuid()) @map("tag_studystyle_id") @db.Uuid
  code String @unique @db.VarChar(50)
  name String @db.VarChar(255)

  profiles  Profile[]
  userStats UserStyleStats[]

  @@map("tag_study_styles")
}

model TagLearningGoal {
  id   String @id @default(uuid()) @map("tag_learninggoal_id") @db.Uuid
  code String @unique @db.VarChar(50)
  name String @db.VarChar(255)

  profiles  Profile[]
  userStats UserGoalStats[]

  @@map("tag_learning_goals")
}

model TagGender {
  id   String @id @default(uuid()) @map("tag_gender_id") @db.Uuid
  code String @unique @db.VarChar(50)
  name String @db.VarChar(255)

  profiles Profile[]

  @@map("tag_genders")
}

model TagStudyDay {
  id   String @id @default(uuid()) @map("tag_studyday_id") @db.Uuid
  code String @unique @db.VarChar(50)
  name String @db.VarChar(255)

  profiles  Profile[]
  userSlots UserStudySlot[]

  @@map("tag_study_days")
}

model TagStudyTime {
  id   String @id @default(uuid()) @map("tag_studytime_id") @db.Uuid
  code String @unique @db.VarChar(50)
  name String @db.VarChar(255)

  profiles  Profile[]
  userSlots UserStudySlot[]

  @@map("tag_study_times")
}

// ==============================
// 4. PROFILE
// ==============================

model Profile {
  id                String   @id @default(uuid()) @map("profile_id") @db.Uuid
  userId            String   @unique @map("user_id") @db.Uuid
  usernameCode      String   @unique @map("username_code") @db.VarChar(50)
  username          String   @map("username") @db.VarChar(255)
  avatarUrl         String?  @map("avatar_url") @db.VarChar(255)
  profilePictureUrl String?  @map("profile_picture_url") @db.VarChar(255)
  gender            Gender   @default(PREFER_NOT_TO_SAY)
  birthday          DateTime @db.Date
  bio               String?  @db.Text
  school            String?  @db.VarChar(255)
  achievement       String?  @db.Text

  // Tags Foreign Keys
  tagLevelId        String  @map("tag_level_id") @db.Uuid
  tagSubjectId      String  @map("tag_subject_id") @db.Uuid
  tagLearningGoalId String? @map("tag_learninggoal_id") @db.Uuid
  tagStudyDayId     String? @map("tag_studyday_id") @db.Uuid
  tagStudyTimeId    String? @map("tag_studytime_id") @db.Uuid
  tagGenderId       String? @map("tag_gender_id") @db.Uuid
  tagStudyStyleId   String? @map("tag_studystyle_id") @db.Uuid

  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamp
  updatedAt DateTime  @updatedAt @map("updated_at") @db.Timestamp

  // Relations
  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  tagLevel        TagLevel         @relation(fields: [tagLevelId], references: [id])
  tagSubject      TagSubject       @relation(fields: [tagSubjectId], references: [id])
  tagLearningGoal TagLearningGoal? @relation(fields: [tagLearningGoalId], references: [id])
  tagStudyDay     TagStudyDay?     @relation(fields: [tagStudyDayId], references: [id])
  tagStudyTime    TagStudyTime?    @relation(fields: [tagStudyTimeId], references: [id])
  tagGender       TagGender?       @relation(fields: [tagGenderId], references: [id])
  tagStudyStyle   TagStudyStyle?   @relation(fields: [tagStudyStyleId], references: [id])

  @@map("profiles")
}

// ==============================
// 5. MATCHING & SWIPING
// ==============================

model Swipe {
  id        String    @id @default(uuid()) @map("swipe_id") @db.Uuid
  swiperId  String    @map("swiper_id") @db.Uuid
  targetId  String    @map("target_id") @db.Uuid
  isLike    Boolean   @map("is_like")
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamp
  updatedAt DateTime  @updatedAt @map("updated_at") @db.Timestamp

  swiper User @relation("Swiper", fields: [swiperId], references: [id], onDelete: Cascade)
  target User @relation("Target", fields: [targetId], references: [id], onDelete: Cascade)

  matchesAsSwipe1 Match[] @relation("MatchSwipe1")
  matchesAsSwipe2 Match[] @relation("MatchSwipe2")

  @@unique([swiperId, targetId])
  @@map("swipes")
}

model Match {
  id        String      @id @default(uuid()) @map("match_id") @db.Uuid
  requestId String?     @map("request_id") @db.Uuid // Nullable if matched via swipe
  user1Id   String      @map("user1_id") @db.Uuid
  user2Id   String      @map("user2_id") @db.Uuid
  status    MatchStatus @default(ACTIVE)
  
  swipe1Id  String?     @map("swipe1_id") @db.Uuid
  swipe2Id  String?     @map("swipe2_id") @db.Uuid
  
  matchedAt DateTime  @default(now()) @map("matched_at") @db.Timestamp
  endAt     DateTime? @map("end_at") @db.Timestamp
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamp
  updatedAt DateTime  @updatedAt @map("updated_at") @db.Timestamp

  request ConnectionRequest? @relation(fields: [requestId], references: [id])
  user1   User              @relation("MatchUser1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2   User              @relation("MatchUser2", fields: [user2Id], references: [id], onDelete: Cascade)
  swipe1  Swipe?            @relation("MatchSwipe1", fields: [swipe1Id], references: [id])
  swipe2  Swipe?            @relation("MatchSwipe2", fields: [swipe2Id], references: [id])

  conversations Conversation[]
  notifications Notification[]

  @@unique([user1Id, user2Id])
  @@map("matches")
}

// ==============================
// 6. COMMUNICATION (CHAT & CALL)
// ==============================

model Conversation {
  id             String    @id @default(uuid()) @map("conversation_id") @db.Uuid
  matchId        String    @map("match_id") @db.Uuid
  status         String    @default("OPEN") @db.VarChar(50)
  endAt          DateTime? @map("end_at") @db.Timestamp
  createdAt      DateTime  @default(now()) @map("created_at") @db.Timestamp
  
  lastMessageId  String?   @unique @map("last_message_id") @db.Uuid
  lastMessageAt  DateTime? @map("last_message_at") @db.Timestamp

  match       Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  lastMessage Message? @relation("LastMessage", fields: [lastMessageId], references: [id])

  messages Message[] @relation("ConversationMessages")
  calls    Call[]

  @@map("conversations")
}

model Message {
  id             String      @id @default(uuid()) @map("message_id") @db.Uuid
  senderId       String      @map("sender_id") @db.Uuid
  conversationId String      @map("conversation_id") @db.Uuid
  callId         String?     @map("call_id") @db.Uuid
  
  type           ContentType @default(TEXT)
  text           String?     @db.Text
  fileName       String?     @map("file_name") @db.VarChar(255)
  
  replyToId      String?     @map("reply_to_id") @db.Uuid
  isDeleted      Boolean     @default(false) @map("is_deleted")
  
  createdAt      DateTime  @default(now()) @map("created_at") @db.Timestamp
  updatedAt      DateTime  @updatedAt @map("updated_at") @db.Timestamp
  readAt         DateTime? @map("read_at") @db.Timestamp
  editedAt       DateTime? @map("edited_at") @db.Timestamp

  sender       User         @relation("MessageSender", fields: [senderId], references: [id])
  conversation Conversation @relation("ConversationMessages", fields: [conversationId], references: [id], onDelete: Cascade)
  call         Call?        @relation(fields: [callId], references: [id])

  // Self relation for Reply
  replyTo Message?  @relation("ReplyRelation", fields: [replyToId], references: [id])
  replies Message[] @relation("ReplyRelation")

  // Relation for Conversation.lastMessage
  conversationLast Conversation? @relation("LastMessage")

  attachments Attachment[]
  moderations Moderation[]

  @@map("messages")
}

model Attachment {
  id        String    @id @default(uuid()) @map("attachment_id") @db.Uuid
  messageId String?   @map("message_id") @db.Uuid
  postId    String?   @map("post_id") @db.Uuid
  fileUrl   String    @map("file_url") @db.VarChar(255)
  fileName  String?   @map("file_name") @db.VarChar(255)
  fileMime  String?   @map("file_mime") @db.VarChar(100)
  fileSize  Int?      @map("file_size")
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamp

  message Message?       @relation(fields: [messageId], references: [id], onDelete: Cascade)
  post    CommunityPost? @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@map("attachments")
}

model Call {
  id             String    @id @default(uuid()) @map("call_id") @db.Uuid
  conversationId String    @map("conversation_id") @db.Uuid
  callerId       String    @map("caller_id") @db.Uuid
  recipientId    String    @map("recipient_id") @db.Uuid
  
  callType       CallType  @default(AUDIO) @map("call_type")
  status         String    @default("CONNECTING") @db.VarChar(50)
  
  acceptedAt     DateTime? @map("accepted_at") @db.Timestamp
  endedAt        DateTime? @map("ended_at") @db.Timestamp
  duration       Int?      @map("duration") // Seconds
  endedById      String?   @map("ended_by_id") @db.Uuid
  
  createdAt      DateTime  @default(now()) @map("created_at") @db.Timestamp

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  caller       User         @relation("Caller", fields: [callerId], references: [id])
  recipient    User         @relation("Recipient", fields: [recipientId], references: [id])
  ender        User?        @relation("CallEnder", fields: [endedById], references: [id])

  messages Message[]

  @@map("calls")
}

// ==============================
// 7. COMMUNITY
// ==============================

model CommunityPost {
  id          String     @id @default(uuid()) @map("post_id") @db.Uuid
  userId      String     @map("user_id") @db.Uuid
  adminId     String?    @map("admin_id") @db.Uuid // Nullable, as not all posts need admin review immediately
  content     String     @map("content") @db.Text
  status      PostStatus @default(DRAFT)
  
  submittedAt DateTime? @map("submitted_at") @db.Timestamp
  reviewedAt  DateTime? @map("reviewed_at") @db.Timestamp
  publishedAt DateTime? @map("published_at") @db.Timestamp
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamp

  author User  @relation("PostAuthor", fields: [userId], references: [id], onDelete: Cascade)
  admin  User? @relation("PostAdmin", fields: [adminId], references: [id])

  comments      Comment[]
  requests      ConnectionRequest[]
  attachments   Attachment[]
  moderations   Moderation[]
  notifications Notification[]

  @@map("community_posts")
}

model Comment {
  id        String    @id @default(uuid()) @map("comment_id") @db.Uuid
  userId    String    @map("user_id") @db.Uuid
  postId    String    @map("post_id") @db.Uuid
  content   String    @db.Text
  isDeleted Boolean   @default(false) @map("is_deleted")
  deletedAt DateTime? @map("deleted_at") @db.Timestamp
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamp

  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  post        CommunityPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  moderations Moderation[]

  @@map("comments")
}

model ConnectionRequest {
  id         String           @id @default(uuid()) @map("request_id") @db.Uuid
  postId     String           @map("post_id") @db.Uuid
  fromUserId String           @map("from_user_id") @db.Uuid
  toUserId   String           @map("to_user_id") @db.Uuid
  message    String?          @db.Text
  status     ConnectionStatus @default(PENDING)
  acceptedAt DateTime?        @map("accepted_at") @db.Timestamp
  createdAt  DateTime         @default(now()) @map("created_at") @db.Timestamp

  post     CommunityPost @relation(fields: [postId], references: [id])
  fromUser User          @relation("RequestFrom", fields: [fromUserId], references: [id], onDelete: Cascade)
  toUser   User          @relation("RequestTo", fields: [toUserId], references: [id], onDelete: Cascade)

  matches       Match[]
  notifications Notification[]

  @@map("connection_requests")
}

// ==============================
// 8. MODERATION & SAFETY
// ==============================

model ViolationKeyword {
  id        String   @id @default(uuid()) @map("word_id") @db.Uuid
  text      String   @unique @map("word_text") @db.VarChar(255)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamp

  moderations Moderation[]

  @@map("violation_keywords")
}

model Moderation {
  id             String           @id @default(uuid()) @map("moderation_id") @db.Uuid
  type           String           @db.VarChar(50) // e.g. "SPAM", "HATE_SPEECH"
  source         String           @db.VarChar(50) // "USER_REPORT", "SYSTEM_SCAN"
  
  targetId       String           @map("target_id") @db.Uuid
  reporterId     String?          @map("reporter_id") @db.Uuid
  reviewerId     String?          @map("reviewer_id") @db.Uuid
  
  // Polymorphic References (Nullable)
  messageId      String?          @map("message_id") @db.Uuid
  commentId      String?          @map("comment_id") @db.Uuid
  postId         String?          @map("post_id") @db.Uuid
  violationWordId String?         @map("word_id") @db.Uuid

  reason         String?          @db.Text
  action         ModerationAction @default(NONE)
  status         ModerationStatus @default(PENDING)
  
  violationCount Int              @default(1) @map("violation_count")
  reviewedAt     DateTime?        @map("reviewed_at") @db.Timestamp
  createdAt      DateTime         @default(now()) @map("created_at") @db.Timestamp
  updatedAt      DateTime         @updatedAt @map("updated_at") @db.Timestamp

  // Relations
  target   User              @relation("ModTarget", fields: [targetId], references: [id])
  reporter User?             @relation("ModReporter", fields: [reporterId], references: [id])
  reviewer User?             @relation("ModReviewer", fields: [reviewerId], references: [id])
  
  message  Message?          @relation(fields: [messageId], references: [id])
  comment  Comment?          @relation(fields: [commentId], references: [id])
  post     CommunityPost?    @relation(fields: [postId], references: [id])
  word     ViolationKeyword? @relation(fields: [violationWordId], references: [id])

  logs          ModerationLog[]
  notifications Notification[]

  @@map("moderations")
}

model ModerationLog {
  id           String           @id @default(uuid()) @map("log_id") @db.Uuid
  moderationId String           @map("moderation_id") @db.Uuid
  adminId      String           @map("admin_id") @db.Uuid
  action       ModerationAction 
  note         String?          @db.Text
  createdAt    DateTime         @default(now()) @map("created_at") @db.Timestamp

  moderation Moderation @relation(fields: [moderationId], references: [id], onDelete: Cascade)
  admin      User       @relation("ModLogAdmin", fields: [adminId], references: [id])

  @@map("moderation_logs")
}

model Notification {
  id          String    @id @default(uuid()) @map("noti_id") @db.Uuid
  userId      String    @map("user_id") @db.Uuid
  content     String    @db.Text
  type        String    @db.VarChar(50) // e.g. "MATCH", "MESSAGE", "SYSTEM"
  
  // Reference IDs (Nullable)
  matchId     String?   @map("match_id") @db.Uuid
  requestId   String?   @map("request_id") @db.Uuid
  postId      String?   @map("post_id") @db.Uuid
  moderationId String?  @map("moderation_id") @db.Uuid
  
  isRead      Boolean   @default(false) @map("is_read")
  readAt      DateTime? @map("read_at") @db.Timestamp
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamp

  user      User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  match     Match?             @relation(fields: [matchId], references: [id])
  request   ConnectionRequest? @relation(fields: [requestId], references: [id])
  post      CommunityPost?     @relation(fields: [postId], references: [id])
  violation Moderation?        @relation(fields: [moderationId], references: [id])

  @@map("notifications")
}

// ==============================
// 9. STATISTICS & METRICS
// ==============================

model UserStudySlot {
  id             String   @id @default(uuid()) @map("slot_id") @db.Uuid
  userId         String   @map("user_id") @db.Uuid
  tagStudyDayId  String   @map("tag_studyday_id") @db.Uuid
  tagStudyTimeId String   @map("tag_studytime_id") @db.Uuid
  createdAt      DateTime @default(now()) @map("created_at") @db.Timestamp

  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  tagStudyDay  TagStudyDay  @relation(fields: [tagStudyDayId], references: [id])
  tagStudyTime TagStudyTime @relation(fields: [tagStudyTimeId], references: [id])

  @@unique([userId, tagStudyDayId, tagStudyTimeId])
  @@map("user_study_slots")
}

model UserStyleStats {
  id              String   @id @default(uuid()) @map("stat_id") @db.Uuid
  userId          String   @map("user_id") @db.Uuid
  tagStudyStyleId String   @map("tag_studystyle_id") @db.Uuid
  
  seenCount       Int      @default(0) @map("seen_count")
  likeCount       Int      @default(0) @map("like_count")
  likeRate        Float?   @map("like_rate")
  updatedAt       DateTime @updatedAt @map("updated_at") @db.Timestamp

  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  tagStudyStyle TagStudyStyle @relation(fields: [tagStudyStyleId], references: [id])

  @@unique([userId, tagStudyStyleId])
  @@map("user_style_stats")
}

model UserGoalStats {
  id                String   @id @default(uuid()) @map("stat_id") @db.Uuid
  userId            String   @map("user_id") @db.Uuid
  tagLearningGoalId String   @map("tag_learninggoal_id") @db.Uuid
  
  seenCount         Int      @default(0) @map("seen_count")
  likeCount         Int      @default(0) @map("like_count")
  likeRate          Float?   @map("like_rate")
  updatedAt         DateTime @updatedAt @map("updated_at") @db.Timestamp

  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  tagLearningGoal TagLearningGoal @relation(fields: [tagLearningGoalId], references: [id])

  @@unique([userId, tagLearningGoalId])
  @@map("user_goal_stats")
}